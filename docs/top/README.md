# top

- 프로세스들의 상태와 CPU, 메모리 사용률 확인

```shell
$ top
```

![](/docs/top/images/top.png)

## hot key

- 1: Cpu(s)가 각각의 CPU로 변한다. 평균으로 볼 수 없었던 CPU의 불균형 문제들을 확인할 수 있다.
- d: 인터벌을 변경한다. (기본 3초) `Change delay from 3.0 to <input>`

![](/docs/top/images/top-hotkey.png)

## CPU Usage (us, wa)

- us는 user를 의미하며, 프로세스의 일반적인 CPU 사용량을 의미한다.
- wa는 waiting을 의미하며, I/O 작업을 대기할 때의 CPU 사용량이다.

us가 높을 경우 CPU를 많이 사용하고 있음을 의미하며 더 높은 HZ 혹은 더 많은 CPU로 해결할 수 있다. 반대로 wa가 높다는 것은 I/O가 많다는 의미이며 더 좋은 블록 디바이스를 가진 서버로 변경하여 해결할 수 있다.

### CPU가 고르게 사용되고 있는가?

CPU 하나만을 사용하는 싱글 스레드 애플리케이션이라면 정상이겠지만, 여러개의 CPU 중에서 특정 CPU만 높다는 것은 정상이 아니라는 의미다.

## 프로세스 상태

- D: uninterruptible sleep (I/O)
- R: running (CPU)
- S: sleeping
- Z: zombie

![](/docs/top/images/top-process-status.png)

R & D 상태는 `uptime`에서도 사용되었듯, Load Average에 포함된다.

```
1. fork() 시스템 콜을 통해 프로세스 생성 (exec() 생략)
2. CPU를 기다리는 상태 (W)
3. CPU 할당된 상태 (R)
4. I/O를 기다려야할 경우 (D)
5. 할당된 CPU를 모두 사용하거나 I/O 대기가 완료된 상태 (W)
6. sleep() 시스템 콜을 만나 명시적으로 잠을 자야하는 상태 (S)
7. S 상태에서 깨어난 상태 (W)
8. exit()
```

### Zombie 프로세스

- 부모 프로세스가 죽었음에도 살아있는 자식 프로세스

일반적으로라면 자식 프로세스가 모두 정상적으로 종료될 때까지 부모 프로세스는 대기하다가 자식 프로세스 종료되면 부모 프로세스도 그 후에 종료되는 과정을 거친다.

```
1. 부모 프로세스가 fork()로 자식 프로세스 생성
2. 자식 프로세스가 정상적으로 종료될 때까지 부모 프로세스 대기
3. 자식 프로세스 종료
4. 부모 프로세스 종료
```

보통 커널은 부모 프로세스가 죽을 경우 자식 프로세스까지 강제로 죽이지만, 자식 프로세스가 정상적으로 돌고 있을 때 부모 프로세스가 대기하지 못하고 먼저 종료되는 상황이 존재한다. 즉, 자식 프로세스가 종료되었을 때 보고해야할 부모가 없는 상황인 셈이다.

```
1. 부모 프로세스가 fork()로 자식 프로세스 생성
2. 부모 프로세스가 대기를 못하고 종료
3. 자식 프로세스 종료
```

좀비 프로세스는 시스템 리소스를 사용하지는 않는다. 하지만 좀비 프로세스 또한 프로세스이기에 PID 고갈을 발생시킬 수 있다. PID 부족해질 경우 더이상 프로세스를 생성할 수 없는 상황이 발생할 수 있다.

참고로 동시에 존재할 수 있는 프로세스의 확인은 `sysctl -a | grep -i pid_max` 명령어를 통해 확인할 수 있다.

## 정리

- `top` 명령어를 통해 프로세스의 상태, CPU, 메모리 사용량을 알 수 있다.
- CPU 사용량중 us가 높을 경우 CPU를 많이 사용하는 워크로드를, wa가 높을 경우 I/O를 많이 사용하는 워크로드를 의미한다.
- 멀티코어 환경일경우 모든 CPU를 사용하고 있는지 확인해야한다.
- 프로세스의 상태에는 R, D, S, Z가 있다.
